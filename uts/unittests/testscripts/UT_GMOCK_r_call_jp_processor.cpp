/*
 * test script file generated by uts
 */

#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include <dlfcn.h>

#define private public

#pragma GCC push_options
#pragma GCC optimize("O0")
#pragma GCC optimize("-fno-inline")
// Include Source File for testing!!
#include "../src/processor/r_call_jp_processor.cpp"
#pragma GCC pop_options
using namespace android;
using namespace oc;
using namespace cv;
using namespace sl;

// Include MOCK FILES!!
#include "mock/service/Handler_mock.h"
#include "mock/service/BpBinder_mock.h"
#include "mock/service/Timer_mock.h"
#include "mock/service/OperationModeManager_mock.h"
#include "mock/service/IServiceManager_mock.h"
#include "mock/src/receiver/someip_manager_mock.h"
#include "mock/src/processor/processor_base_mock.h"
#include "mock/src/services_adapter/config_manager_adapter_mock.h"
#include "mock/src/services_adapter/hmi_manager_adapter_mock.h"
#include "mock/src/services_adapter/audio_manager_adapter_mock.h"
#include "mock/src/services_adapter/telephone_manager_adapter_mock.h"
#include "mock/src/services_adapter/app_manager_adapter_mock.h"
#include "mock/src/services_adapter/power_manager_adapter_mock.h"
#include "mock/src/services_adapter/rim_adapter_mock.h"
#include "mock/src/services_adapter/comm_manager_adapter_mock.h"
#include "mock/src/services_adapter/vehicle_variation_info_adapter_mock.h"
// #include "mock/src/services_adapter/AlarmManagerAdapter_mock.h"
#include "mock/src/oem_call_handler_mock.h"
#include "mock/src/logger_mock.h"
#include "mock/src/utils/utils_common_mock.h"
#include "mock/src/data/data_builder_rcall_mock.h"
#include <services/ApplicationManagerService/ApplicationManager.h>
#include "mock/service/ApplicationManager_mock.h"
#include "mock/src/oem_call_app_if_mock.h"
#include "mock/src/oem_call_app_constants_mock.h"
#include "mock/src/oem_call_timer_mock.h"
#include "mock/src/data/data_builder_rcall_mock.h"
#include "mock/src/data/i_data_builder_mock.h"


/*
 * Define Mock Class / function
*/
class Base_RCallProcessor {
public:
    virtual ~Base_RCallProcessor(){ }
};

class Mock_RCallProcessor : public Base_RCallProcessor {
public:
};

Mock_RCallProcessor *M_RCallProcessor;

using ::testing::Return;
using ::testing::_;
using ::testing::A;
using ::testing::ReturnRef;
using ::testing::Values;
using ::testing::SetArgPointee;
using ::testing::SetArrayArgument;
using ::testing::SaveArg;
using ::testing::SaveArgPointee;
using ::testing::DoAll;
using ::testing::Args;
using ::testing::AllOf;
using ::testing::AtLeast;
using ::testing::Combine;
bool Bypass = true;
class RCallProcessorTest : public ::testing::Test {
protected:
    virtual void SetUp(){
        M_RCallProcessor = new Mock_RCallProcessor();
        M_OEMCallAppIF = new MockOEMCallAppIF();
        // M_AlarmManagerAdapter = new MockAlarmManagerAdapter();
        M_someIP_manager = new MocksomeIP_manager();
        M_AppManagerAdapter = new MockAppManagerAdapter();
        M_PowerManagerAdapter = new MockPowerManagerAdapter();
        M_Common = new MockCommon();
        M_Handler = new MockHandler();
        M_TelephoneManager = new MockTelephoneManager();
        M_ConfigManager = new MockConfigManager();
        M_HmiManagerAdapter = new MockHmiManagerAdapter();
        M_OperationModeManager = new MockOperationModeManager();
        M_AudioManagerAdapter = new MockAudioManagerAdapter();
        M_Timer = new MockTimer();
        M_DataBuilderRCall = new MockDataBuilderRCall();
        M_RIMAdapter = new MockRIMAdapter();
        M_IDataBuilder = new MockIDataBuilder();
        ecallapp::M_VehicleVariationAdapter = new ecallapp::MockVehicleVariationAdapter();

        // EXPECT_CALL(*M_AlarmManagerAdapter, init()).WillRepeatedly(Return());
        // EXPECT_CALL(*M_someIP_manager, registerSomeipProviderReceiver()).WillRepeatedly(Return());
    }
    virtual void TearDown(){
        delete M_RCallProcessor;
        delete M_someIP_manager;
        delete M_AppManagerAdapter;
        delete M_PowerManagerAdapter;
        delete M_Common;
        delete M_Handler;
        delete M_TelephoneManager;
        delete M_ConfigManager;
        delete M_HmiManagerAdapter;
        delete M_OperationModeManager;
        delete M_AudioManagerAdapter;
        delete M_Timer;
        delete M_DataBuilderRCall;
        delete M_RIMAdapter;
        delete M_IDataBuilder;
        delete ecallapp::M_VehicleVariationAdapter;
        // delete M_AlarmManagerAdapter;
    }
};

class r_call_jp_processorTest : public ::testing::Test {
protected:
    virtual void SetUp(){
        M_RCallProcessor = new Mock_RCallProcessor();
        M_OEMCallAppIF = new MockOEMCallAppIF();
        // M_AlarmManagerAdapter = new MockAlarmManagerAdapter();
        M_someIP_manager = new MocksomeIP_manager();
        M_AppManagerAdapter = new MockAppManagerAdapter();
        M_PowerManagerAdapter = new MockPowerManagerAdapter();
        M_Common = new MockCommon();
        M_Handler = new MockHandler();
        M_TelephoneManager = new MockTelephoneManager();
        M_ConfigManager = new MockConfigManager();
        M_HmiManagerAdapter = new MockHmiManagerAdapter();
        M_OperationModeManager = new MockOperationModeManager();
        M_AudioManagerAdapter = new MockAudioManagerAdapter();
        M_Timer = new MockTimer();
        M_DataBuilderRCall = new MockDataBuilderRCall();
        M_RIMAdapter = new MockRIMAdapter();
        M_IDataBuilder = new MockIDataBuilder();

        // EXPECT_CALL(*M_AlarmManagerAdapter, init()).WillRepeatedly(Return());
        // EXPECT_CALL(*M_someIP_manager, registerSomeipProviderReceiver()).WillRepeatedly(Return());
    }
    virtual void TearDown(){
        delete M_RCallProcessor;
        delete M_someIP_manager;
        delete M_AppManagerAdapter;
        delete M_PowerManagerAdapter;
        delete M_Common;
        delete M_Handler;
        delete M_TelephoneManager;
        delete M_ConfigManager;
        delete M_HmiManagerAdapter;
        delete M_OperationModeManager;
        delete M_AudioManagerAdapter;
        delete M_Timer;
        delete M_DataBuilderRCall;
        delete M_RIMAdapter;
        delete M_IDataBuilder;
        // delete M_AlarmManagerAdapter;
    }
};


/**
 *   @brief This is a test script for the RCallProcessor_RCallProcessor function
 *   @classID RCallProcessor
 *   @methodID RCallProcessor
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_RCallProcessor_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_RCallProcessor_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_processor_init function
 *   @classID RCallProcessor
 *   @methodID init
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_init_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_init_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sp<sl::SLLooper> looper = new sl::SLLooper();
    MockOEMCallAppIF& app_ = *M_OEMCallAppIF;
    android::sp<OemCallHandler> spHandler = new OemCallHandler(looper, app_);
    std::shared_ptr<AdapterLocator> adapters = std::make_shared<AdapterLocator>(spHandler);
    std::shared_ptr<ProcessorBase> processorBase = std::make_shared<RCallProcessor>();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*ecallapp::M_VehicleVariationAdapter, isFeatureAvailableInRegion(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).WillRepeatedly(Return());
    processorBase->init(spHandler, adapters);
    EXPECT_EQ(1, 1);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_processor_init function
 *   @classID RCallProcessor
 *   @methodID init
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_init_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_init_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sp<sl::SLLooper> looper = new sl::SLLooper();
    MockOEMCallAppIF& app_ = *M_OEMCallAppIF;
    android::sp<OemCallHandler> spHandler = new OemCallHandler(looper, app_);
    std::shared_ptr<AdapterLocator> adapters = std::make_shared<AdapterLocator>(spHandler);
    std::shared_ptr<ProcessorBase> processorBase = std::make_shared<RCallProcessor>();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*ecallapp::M_VehicleVariationAdapter, isFeatureAvailableInRegion(_)).WillRepeatedly(Return(false));
    processorBase->init(spHandler, adapters);
    EXPECT_EQ(1, 1);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_processor_init function
 *   @classID RCallProcessor
 *   @methodID init
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_init_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_init_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sp<sl::SLLooper> looper = new sl::SLLooper();
    MockOEMCallAppIF& app_ = *M_OEMCallAppIF;
    android::sp<OemCallHandler> spHandler = new OemCallHandler(looper, app_);
    std::shared_ptr<AdapterLocator> adapters = std::make_shared<AdapterLocator>(spHandler);
    std::shared_ptr<ProcessorBase> processorBase = std::make_shared<RCallProcessor>();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*ecallapp::M_VehicleVariationAdapter, isFeatureAvailableInRegion(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).WillRepeatedly(Return());
    processorBase->init(spHandler, adapters);
    EXPECT_EQ(1, 1);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_isAvailable function
 *   @classID RCallProcessor
 *   @methodID isAvailable
 *   @paramList
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_isAvailable_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_isAvailable_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    EXPECT_CALL(*ecallapp::M_VehicleVariationAdapter, isFeatureAvailableInRegion(_)).WillRepeatedly(Return(false));
    testObj->isAvailable();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_isAvailable function
 *   @classID RCallProcessor
 *   @methodID isAvailable
 *   @paramList
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_isAvailable_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_isAvailable_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    EXPECT_CALL(*ecallapp::M_VehicleVariationAdapter, isFeatureAvailableInRegion(_)).WillRepeatedly(Return(false));
    testObj->isAvailable();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the RCallProcessor_isAvailable function
 *   @classID RCallProcessor
 *   @methodID isAvailable
 *   @paramList
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_isAvailable_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_isAvailable_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    EXPECT_CALL(*ecallapp::M_VehicleVariationAdapter, isFeatureAvailableInRegion(_)).WillRepeatedly(Return(false));
    testObj->isAvailable();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    sl::Message *msg = new sl::Message();
    //EOperationMode op_mode;
    //EXPECT_CALL(*M_OperationModeManager, instance()).WillRepeatedly(Return(op_mode));
    //EXPECT_CALL(*M_OperationModeManager, getOperationMode(_)).WillRepeatedly(Return(0));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(false));
    testObj->doProcessorHandler(msg::RCALL_TRIGGER, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::RCALL_TIMER_EXPIRED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_CM_BINDER_DIED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(2);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(2);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(2).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_CM_TEAR_DOWN, msg);
    EXPECT_EQ(Bypass, true);
    delete testObj;
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC005
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC005){
// Please enable and make test code here!!
#if 0
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(2);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(2);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(2).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_CM_TEAR_DOWN, msg);
    EXPECT_EQ(Bypass, true);
    delete testObj;
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC006
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC006){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_TelephoneManager, getCallState()).Times(1).WillOnce(Return(telephony::TelephonyManager::PRECISE_CALL_STATE_IDLE));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::RCALL_TURNOFF, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC007
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC007){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->isRequestedAudioRetry = true;
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(true));
    sl::Message *msg = new sl::Message();
    msg->arg1 = (int32_t) AudioManagerAdapter::AudioFile::Tone_1;
    testObj->doProcessorHandler(msg::MSC_CM_US_REQUEST_RETRY_PLAY_AUDIO, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC008
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC008){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->isRequestedAudioRetry = false;
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSC_CM_US_REQUEST_RETRY_PLAY_AUDIO, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC009
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC009){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::VOICE_COMMUNICATION;
    sl::Message *msg = new sl::Message();
    msg->arg1 = serviceinfo::AudioState::IDLE;
    testObj->doProcessorHandler(msg::MSG_AUDIO_PLAY_STATE_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0010
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0010){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    sl::Message *msg = new sl::Message();
    msg->arg1 = serviceinfo::AudioState::PLAYING;
    testObj->doProcessorHandler(msg::MSG_AUDIO_PLAY_STATE_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC022
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC022){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    sl::Message *msg = new sl::Message();
    msg->arg1 = (uint8_t) 3;
    testObj->doProcessorHandler(msg::MSG_AUDIO_PLAY_STATE_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0011
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0011){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_CONFIG_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0012
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0012){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::STANDBY;
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_OFF));
    EXPECT_CALL(*M_PowerManagerAdapter, getIGStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_OFF));
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_POWER_STATE_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0013
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0013){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::STANDBY;
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::RCALL_END_ERROR_LED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0014
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0014){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_RIM_GTC_RESPONSE, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0015
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0015){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(2);
    sl::Message *msg = new sl::Message();
    msg->arg1 = POWER_MODE_VALUE::POWER_MODE_LOW_POWER;
    testObj->doProcessorHandler(msg::MSG_POWER_MODE_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0016
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0016){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::OFF;
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_TELEM_CALL_PRECISE_STATE_CHANGED, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0017
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0017){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    sl::Message *msg = new sl::Message();
    testObj->doProcessorHandler(msg::MSG_SOMEIP_REQUEST_CLEARUP_R_CALL, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0018
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0018)
{
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::OFF;
    sl::Message *msg = new sl::Message();
    uint8_t data = 0x01;
    sp<Buffer> payload = new Buffer();
    payload->append(&data, 1);
    msg->spRef = payload;
    testObj->doProcessorHandler(msg::MSG_SOMEIP_REQUEST_CLEARUP_R_CALL, msg);
    EXPECT_EQ(Bypass, true);
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0019
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0019)
{
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::OFF;
    sl::Message *msg = new sl::Message();
    uint8_t data = 0x00;
    sp<Buffer> payload = new Buffer();
    payload->append(&data, 1);
    msg->spRef = payload;
    // EXPECT_CALL(*M_Common, sendToICB(_,_)).WillRepeatedly(Return(1));
    testObj->doProcessorHandler(msg::MSG_SOMEIP_REQUEST_CLEARUP_R_CALL, msg);
    EXPECT_EQ(Bypass, true);
}
/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0020
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0020){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::OFF;
    sl::Message *msg = new sl::Message();
    uint8_t data = 0x03;
    sp<Buffer> payload = new Buffer();
    payload->append(&data, 1);
    msg->spRef = payload;

    testObj->doProcessorHandler(msg::MSG_SOMEIP_REQUEST_CLEARUP_R_CALL, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC0021
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC0021){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::OFF;
    sl::Message *msg = new sl::Message();
    sp<Buffer> payload = new Buffer();
    msg->spRef = payload;

    testObj->doProcessorHandler(msg::MSG_SOMEIP_REQUEST_CLEARUP_R_CALL, msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_doProcessorHandler function
 *   @classID RCallProcessor
 *   @methodID doProcessorHandler
 *   @paramList uint32_t what,const sp<sl::Message>& msg
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_doProcessorHandler_TC024
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_doProcessorHandler_TC024){
    for (int i = 0; i < 8; ++i)
    {
        RCallProcessor *testObj = new RCallProcessor();
        testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
        testObj->impl_->state = State::OFF;
        sl::Message *msg = new sl::Message();
        sp<Buffer> payload = new Buffer();
        msg->spRef = payload;
        msg->arg1                                   = (i & (1 << 2)) ? 1 : 0;
        testObj->impl_->isNeededToSendTelmuteAgain  = (i & (1 << 1)) ? true : false;
        auto someIpResponse                         = (i & (1 << 0)) ? true : false;
        testObj->doProcessorHandler(msg::MSG_SOMEIP_PROVIDER_ETH_READY, msg);
    }
    EXPECT_EQ(Bypass, true);
}

/**
 *   @brief This is a test script for the RCallProcessor_onTimerEvent function
 *   @classID RCallProcessor
 *   @methodID onTimerEvent
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_onTimerEvent_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_onTimerEvent_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->onTimerEvent(100);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the RCallProcessor_onTimerEvent function
 *   @classID RCallProcessor
 *   @methodID onTimerEvent
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_onTimerEvent_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_onTimerEvent_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->onTimerEvent(100);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the RCallProcessor_onTimerEvent function
 *   @classID RCallProcessor
 *   @methodID onTimerEvent
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessorTest_onTimerEvent_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(RCallProcessorTest, RCallProcessor_onTimerEvent_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->onTimerEvent(100);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_getOperationMode function
 *   @classID r_call_jp_processor
 *   @methodID getOperationMode
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_getOperationMode_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_getOperationMode_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    EOperationMode op_mode;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    st.getOperationMode(op_mode);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_getOperationMode function
 *   @classID r_call_jp_processor
 *   @methodID getOperationMode
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_getOperationMode_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_getOperationMode_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    EOperationMode op_mode;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    st.getOperationMode(op_mode);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_getOperationMode function
 *   @classID r_call_jp_processor
 *   @methodID getOperationMode
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_getOperationMode_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_getOperationMode_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    EOperationMode op_mode;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    st.getOperationMode(op_mode);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_requestPlayAudio function
 *   @classID r_call_jp_processor
 *   @methodID requestPlayAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_requestPlayAudio_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_requestPlayAudio_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->requestPlayAudio(AudioManagerAdapter::AudioFile::Tone_1);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_requestPlayAudio function
 *   @classID r_call_jp_processor
 *   @methodID requestPlayAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_requestPlayAudio_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_requestPlayAudio_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->requestPlayAudio(AudioManagerAdapter::AudioFile::Tone_1);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_requestPlayAudio function
 *   @classID r_call_jp_processor
 *   @methodID requestPlayAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_requestPlayAudio_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_requestPlayAudio_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->requestPlayAudio(AudioManagerAdapter::AudioFile::Tone_1);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_indicateError function
 *   @classID r_call_jp_processor
 *   @methodID RCallProcessor_indicateError
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessor_indicateError_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_indicateError_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->indicateError(AudioManagerAdapter::AudioFile::Tone_1, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_indicateError function
 *   @classID r_call_jp_processor
 *   @methodID RCallProcessor_indicateError
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessor_indicateError_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_indicateError_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->indicateError(AudioManagerAdapter::AudioFile::Tone_1, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_indicateError function
 *   @classID r_call_jp_processor
 *   @methodID RCallProcessor_indicateError
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessor_indicateError_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_indicateError_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->indicateError(AudioManagerAdapter::AudioFile::Tone_1, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_indicateError function
 *   @classID r_call_jp_processor
 *   @methodID RCallProcessor_indicateError
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID RCallProcessor_indicateError_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_indicateError_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(true));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->indicateError(AudioManagerAdapter::AudioFile::Tone_1, "");
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUp function
 *   @classID r_call_jp_processor
 *   @methodID cleanUp
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUp_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUp_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->cleanUp(CleanupAction::WAIT_FOR_AUDIO_INDICATE_FINISHED, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUp function
 *   @classID r_call_jp_processor
 *   @methodID cleanUp
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processor_cleanUp_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUp_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->cleanUp(CleanupAction::WAIT_FOR_AUDIO_INDICATE_FINISHED, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUp function
 *   @classID r_call_jp_processor
 *   @methodID cleanUp
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processor_cleanUp_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUp_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));

    testObj->impl_->cleanUp(CleanupAction::WAIT_FOR_AUDIO_INDICATE_FINISHED, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpBySomeIP function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpBySomeIP
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processor_cleanUpBySomeIP_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpBySomeIP_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    testObj->impl_->cleanUpBySomeIP(CleanupAction::WAIT_FOR_AUDIO_INDICATE_FINISHED, "");
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpBySomeIP function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpBySomeIP
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpBySomeIP_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpBySomeIP_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::STANDBY;
    testObj->impl_->cleanUpBySomeIP(CleanupAction::WAIT_FOR_AUDIO_INDICATE_FINISHED, "");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpBySomeIP function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpBySomeIP
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpBySomeIP_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpBySomeIP_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    testObj->impl_->cleanUpBySomeIP(CleanupAction::RESET_ALL_MODULE_IMMIDIATELY, "");
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpBySomeIP function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpBySomeIP
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpBySomeIP_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpBySomeIP_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::OFF;
    testObj->impl_->cleanUpBySomeIP(CleanupAction::RESET_ALL_MODULE_IMMIDIATELY, "");
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpAudio function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpAudio_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpAudio_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return("TRUE"));
    testObj->impl_->cleanUpAudio();
    EXPECT_EQ(1, 1);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpAudio function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpAudio_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpAudio_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return("TRUE"));
    testObj->impl_->cleanUpAudio();
    EXPECT_EQ(1, 1);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpAudio function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpAudio_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpAudio_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(false));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return("TRUE"));
    testObj->impl_->cleanUpAudio();
    EXPECT_EQ(1, 1);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_turnOffFeature function
 *   @classID r_call_jp_processor
 *   @methodID turnOffFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_turnOffFeature_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_turnOffFeature_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_TelephoneManager, getCallState()).Times(1).WillOnce(Return(telephony::TelephonyManager::PRECISE_CALL_STATE_IDLE));
    testObj->impl_->turnOffFeature(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_turnOffFeature function
 *   @classID r_call_jp_processor
 *   @methodID turnOffFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_turnOffFeature_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_turnOffFeature_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    testObj->impl_->turnOffFeature(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_turnOffFeature function
 *   @classID r_call_jp_processor
 *   @methodID turnOffFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_turnOffFeature_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_turnOffFeature_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    testObj->impl_->turnOffFeature(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_turnOffFeature function
 *   @classID r_call_jp_processor
 *   @methodID turnOffFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_turnOffFeature_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_turnOffFeature_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_TelephoneManager, getCallState()).Times(1).WillOnce(Return(10));
    testObj->impl_->turnOffFeature(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_turnOffFeature function
 *   @classID r_call_jp_processor
 *   @methodID turnOffFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_turnOffFeature_TC005
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_turnOffFeature_TC005){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_TelephoneManager, getCallState()).Times(1).WillOnce(Return(telephony::TelephonyManager::PRECISE_CALL_STATE_IDLE));
    testObj->impl_->spAdapters->spAppManagerAdapter = nullptr;
    testObj->impl_->turnOffFeature(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_subscriptionCheck function
 *   @classID r_call_jp_processor
 *   @methodID subscriptionCheck
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_subscriptionCheck_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_subscriptionCheck_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    testObj->impl_->subscriptionCheck();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_subscriptionCheck function
 *   @classID r_call_jp_processor
 *   @methodID subscriptionCheck
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_subscriptionCheck_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_subscriptionCheck_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    testObj->impl_->subscriptionCheck();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_subscriptionCheck function
 *   @classID r_call_jp_processor
 *   @methodID subscriptionCheck
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_subscriptionCheck_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_subscriptionCheck_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(false));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    testObj->impl_->subscriptionCheck();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startTimer function
 *   @classID r_call_jp_processor
 *   @methodID startTimer
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startTimer_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startTimer_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, setDuration(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_Timer, start()).WillRepeatedly(Return());
    uint32_t timerId = 0;
    uint32_t firstTimeout = 0;
    testObj->impl_->startTimer(timerId, firstTimeout);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startTimer function
 *   @classID r_call_jp_processor
 *   @methodID startTimer
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startTimer_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startTimer_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, setDuration(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_Timer, start()).WillRepeatedly(Return());
    uint32_t timerId = 0;
    uint32_t firstTimeout = 0;
    testObj->impl_->startTimer(timerId, firstTimeout);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startTimer function
 *   @classID r_call_jp_processor
 *   @methodID startTimer
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startTimer_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startTimer_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, setDuration(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_Timer, start()).WillRepeatedly(Return());
    uint32_t timerId = 0;
    uint32_t firstTimeout = 0;
    testObj->impl_->startTimer(timerId, firstTimeout);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_stopTimer function
 *   @classID r_call_jp_processor
 *   @methodID stopTimer
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_stopTimer_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_stopTimer_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    uint32_t timerId = 0;
    testObj->impl_->stopTimer(timerId);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_stopTimer function
 *   @classID r_call_jp_processor
 *   @methodID stopTimer
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_stopTimer_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_stopTimer_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    uint32_t timerId = 0;
    testObj->impl_->stopTimer(timerId);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_stopTimer function
 *   @classID r_call_jp_processor
 *   @methodID stopTimer
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_stopTimer_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_stopTimer_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    uint32_t timerId = 0;
    testObj->impl_->stopTimer(timerId);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startFeature function
 *   @classID r_call_jp_processor
 *   @methodID startFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startFeature_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startFeature_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    std::string featureName = "";
    testObj->impl_->startFeature(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_startFeature function
 *   @classID r_call_jp_processor
 *   @methodID startFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startFeature_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startFeature_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AppManagerAdapter, requestActiveFeature(_)).WillRepeatedly(Return(true));
    std::string featureName = "";
    testObj->impl_->startFeature(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_startFeature function
 *   @classID r_call_jp_processor
 *   @methodID startFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startFeature_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startFeature_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AppManagerAdapter, requestActiveFeature(_)).WillRepeatedly(Return(true));
    std::string featureName = "";
    testObj->impl_->startFeature(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_startFeature function
 *   @classID r_call_jp_processor
 *   @methodID startFeature
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startFeature_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startFeature_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_AppManagerAdapter, requestActiveFeature(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, getPrivacy(_,_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return("TRUE"));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    ITest_DataBuilder temp;
    EXPECT_CALL(*M_DataBuilderRCall, setGPS()).WillRepeatedly(ReturnRef(temp));
    EXPECT_CALL(*M_IDataBuilder, setUtil(_)).WillRepeatedly(ReturnRef(temp));
    EXPECT_CALL(*M_PowerManagerAdapter, getIgnition()).WillRepeatedly(Return("unknown"));
    EXPECT_CALL(*M_IDataBuilder, build()).WillRepeatedly(Return("OK"));
    std::string featureName = "";
    testObj->impl_->startFeature(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startCallProcess function
 *   @classID r_call_jp_processor
 *   @methodID startCallProcess
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startCallProcess_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startCallProcess_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    std::string featureName = "";
    testObj->impl_->startCallProcess(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startCallProcess function
 *   @classID r_call_jp_processor
 *   @methodID startCallProcess
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startCallProcess_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startCallProcess_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    std::string featureName = "";
    testObj->impl_->startCallProcess(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_startCallProcess function
 *   @classID r_call_jp_processor
 *   @methodID startCallProcess
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_startCallProcess_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_startCallProcess_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    std::string featureName = "";
    testObj->impl_->startCallProcess(featureName);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleHmiTrigger function
 *   @classID r_call_jp_processor
 *   @methodID doHandleHmiTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleHmiTrigger_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleHmiTrigger_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    std::string featureName = "";
    testObj->impl_->doHandleHmiTrigger(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleHmiTrigger function
 *   @classID r_call_jp_processor
 *   @methodID doHandleHmiTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleHmiTrigger_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleHmiTrigger_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleHmiTrigger(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleHmiTrigger function
 *   @classID r_call_jp_processor
 *   @methodID doHandleHmiTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleHmiTrigger_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleHmiTrigger_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EOperationMode op_mode;
    op_mode.value = EOperationMode::OEMFactoryMode_ProtectionMode;
    OperationModeManager *OpMode = new OperationModeManager();
    EXPECT_CALL(*M_OperationModeManager, instance()).WillRepeatedly(Return(OpMode));
    EXPECT_CALL(*M_OperationModeManager, getOperationMode(_)).WillRepeatedly(Return(op_mode));
    EXPECT_CALL(*M_OperationModeManager, getOperationMode(_)).WillRepeatedly(::testing::Invoke([&](EOperationMode& Op_Mode) {
        Op_Mode = op_mode;
        return E_OK;
    }));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    testObj->impl_->doHandleHmiTrigger(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleHmiTrigger function
 *   @classID r_call_jp_processor
 *   @methodID doHandleHmiTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleHmiTrigger_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleHmiTrigger_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->state = State::DIAG;
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::DIAG;
    std::string featureName = "";
    testObj->impl_->doHandleHmiTrigger(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleTimerEvent function
 *   @classID r_call_jp_processor
 *   @methodID doHandleTimerEvent
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleTimerEvent_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleTimerEvent_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleTimerEvent(1);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleTimerEvent function
 *   @classID r_call_jp_processor
 *   @methodID doHandleTimerEvent
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleTimerEvent_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleTimerEvent_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleTimerEvent(1);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleTimerEvent function
 *   @classID r_call_jp_processor
 *   @methodID doHandleTimerEvent
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleTimerEvent_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleTimerEvent_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleTimerEvent(3);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleBinderDied function
 *   @classID r_call_jp_processor
 *   @methodID doHandleBinderDied
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processor_doHandleBinderDied_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleBinderDied_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleBinderDied(self::ServiceId::AUDIO);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleBinderDied function
 *   @classID r_call_jp_processor
 *   @methodID doHandleBinderDied
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleBinderDied_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleBinderDied_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleBinderDied(self::ServiceId::TELEPHONY);
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleBinderDied function
 *   @classID r_call_jp_processor
 *   @methodID doHandleBinderDied
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleBinderDied_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleBinderDied_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    std::string featureName = "";
    testObj->impl_->doHandleBinderDied(self::ServiceId::RIM);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleBinderDied function
 *   @classID r_call_jp_processor
 *   @methodID doHandleBinderDied
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleBinderDied_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleBinderDied_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    std::string featureName = "";
    testObj->impl_->doHandleBinderDied(self::ServiceId::RIM);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_doHandleBinderDied function
 *   @classID r_call_jp_processor
 *   @methodID doHandleBinderDied
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doHandleBinderDied_TC005
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doHandleBinderDied_TC005){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    std::string featureName = "";
    testObj->impl_->doHandleBinderDied(self::ServiceId::RIM);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStart function
 *   @classID r_call_jp_processor
 *   @methodID onStart
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStart_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStart_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStart(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onStart function
 *   @classID r_call_jp_processor
 *   @methodID onStart
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStart_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStart_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStart(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStart function
 *   @classID r_call_jp_processor
 *   @methodID onStart
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStart_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStart_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStart(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onUpgrade function
 *   @classID r_call_jp_processor
 *   @methodID onUpgrade
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onUpgrade_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onUpgrade_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onUpgrade(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onUpgrade function
 *   @classID r_call_jp_processor
 *   @methodID onUpgrade
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onUpgrade_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onUpgrade_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onUpgrade(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onUpgrade function
 *   @classID r_call_jp_processor
 *   @methodID onUpgrade
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onUpgrade_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onUpgrade_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onUpgrade(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onTrigger function
 *   @classID r_call_jp_processor
 *   @methodID onTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onTrigger_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onTrigger_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onTrigger(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onTrigger function
 *   @classID r_call_jp_processor
 *   @methodID onTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onTrigger_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onTrigger_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onTrigger(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onTrigger function
 *   @classID r_call_jp_processor
 *   @methodID onTrigger
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onTrigger_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onTrigger_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onTrigger(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPostponed function
 *   @classID r_call_jp_processor
 *   @methodID onPostponed
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPostponed_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPostponed_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onPostponed(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPostponed function
 *   @classID r_call_jp_processor
 *   @methodID onPostponed
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPostponed_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPostponed_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onPostponed(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPostponed function
 *   @classID r_call_jp_processor
 *   @methodID onPostponed
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPostponed_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPostponed_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onPostponed(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStop function
 *   @classID r_call_jp_processor
 *   @methodID onStop
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStop_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStop_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onStop function
 *   @classID r_call_jp_processor
 *   @methodID onStop
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStop_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStop_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::NOT_INIT;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onStop function
 *   @classID RCallProcessor
 *   @methodID onStop
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStop_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStop_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStop function
 *   @classID r_call_jp_processor
 *   @methodID onStop
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStop_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStop_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::DIAG;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStopAudio function
 *   @classID r_call_jp_processor
 *   @methodID onStopAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStopAudio_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStopAudio_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_RIMAdapter, send(_,_));

    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::PREPARING_DATA;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStopAudio();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStopAudio function
 *   @classID r_call_jp_processor
 *   @methodID onStopAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStopAudio_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStopAudio_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));

    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::TERMINATING;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStopAudio();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onStopAudio function
 *   @classID r_call_jp_processor
 *   @methodID onStopAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStopAudio_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStopAudio_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));

    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStopAudio();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onStopAudio function
 *   @classID r_call_jp_processor
 *   @methodID onStopAudio
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onStopAudio_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onStopAudio_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));

    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    const std::string type = "";
    const std::string name = "";
    testObj->impl_->onStopAudio();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));

    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::COMMUNICATING_DATA;
    testObj->impl_->onSeverResponse(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return("Y"));
    // EXPECT_CALL(*M_Common, getConfig("Rcall_Mute_By_MuteLine")).WillRepeatedly(Return("UD"));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::COMMUNICATING_DATA;
    testObj->impl_->onSeverResponse(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return("Y"));
    EXPECT_CALL(*M_Common, getConfig("Rcall_Judge")).WillRepeatedly(Return("UD"));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::COMMUNICATING_DATA;
    testObj->impl_->onSeverResponse(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return("Y"));
    EXPECT_CALL(*M_Common, getConfig("Rcall_Judge")).WillRepeatedly(Return("NG"));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::COMMUNICATING_DATA;
    testObj->impl_->onSeverResponse(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC005
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC005){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return("N"));
    android::sp<RIMResponseType> response = new RIMResponseType();
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::COMMUNICATING_DATA;
    response->responseBody = R"({"phoneNumber": "1234567890"})";
    ret_param_0->spRef = response;
    ret_param_0->getObject(response);
    testObj->impl_->onSeverResponse(ret_param_0);
    EXPECT_EQ(Bypass, true);

#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC006
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC006){
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);

    EXPECT_CALL(*M_Common, getConfig(_)).Times(2)
                                        .WillOnce(Return("N"))
                                        .WillOnce(Return("dm"));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, setDuration(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_Timer, start()).WillRepeatedly(Return());
    EXPECT_CALL(*M_TelephoneManager, dial(_,_)).WillRepeatedly(Return());
    sl::Message *msg = new sl::Message();
    android::sp<RIMResponseType> response = new RIMResponseType();
    response->responseBody = R"({"phoneNumber": "1234567890"})";
    response->serverResponse = serviceinfo::DataResResult::SUCCESS;
    testObj->impl_->state  = State::COMMUNICATING_DATA;
    msg->spRef = response;
    testObj->impl_->onSeverResponse(msg);
    EXPECT_EQ(Bypass, true);
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC007
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC007){
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_Common, getConfig(_)).Times(3)
                                        .WillOnce(Return("N"))
                                        .WillOnce(Return("Y"))
                                        .WillOnce(Return("dm"));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, setDuration(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_Timer, start()).WillRepeatedly(Return());
    EXPECT_CALL(*M_TelephoneManager, dial(_,_)).WillRepeatedly(Return());
    sl::Message *msg = new sl::Message();
    android::sp<RIMResponseType> response = new RIMResponseType();
    response->responseBody = R"({"phoneNumber": "1234567890"})";
    response->serverResponse = serviceinfo::DataResResult::SUCCESS;
    testObj->impl_->state  = State::COMMUNICATING_DATA;
    msg->spRef = response;
    testObj->impl_->onSeverResponse(msg);
    EXPECT_EQ(Bypass, true);
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC008
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC008){
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);

    EXPECT_CALL(*M_Common, getConfig(_)).Times(1)
                                        .WillOnce(Return("N"));
    sl::Message *msg = new sl::Message();
    android::sp<RIMResponseType> response = new RIMResponseType();
    response->responseBody = R"({"phoneNumber": "1234567890"})";
    response->serverResponse = serviceinfo::DataResResult::FAILURE;
    testObj->impl_->state  = State::COMMUNICATING_DATA;
    msg->spRef = response;
    testObj->impl_->onSeverResponse(msg);
    EXPECT_EQ(Bypass, true);
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onSeverResponse function
 *   @classID r_call_jp_processor
 *   @methodID onSeverResponse
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSeverResponse_TC009
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSeverResponse_TC009){
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);

    EXPECT_CALL(*M_Common, getConfig(_)).Times(1)
                                        .WillOnce(Return("N"));
    sl::Message *msg = new sl::Message();
    android::sp<RIMResponseType> response = new RIMResponseType();
    response->responseBody = R"({"phoneNumber": "1234567890"})";
    response->serverResponse = serviceinfo::DataResResult::FAILURE_RETRY;
    testObj->impl_->state  = State::COMMUNICATING_DATA;
    msg->spRef = response;
    testObj->impl_->onSeverResponse(msg);
    EXPECT_EQ(Bypass, true);
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPowerStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onPowerStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPowerStateChanged_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPowerStateChanged_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return("Y"));
    EXPECT_CALL(*M_Common, getConfig("Rcall_Judge")).WillRepeatedly(Return("NG"));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::COMMUNICATING_DATA;
    testObj->impl_->onPowerStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onPowerStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onPowerStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPowerStateChanged_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPowerStateChanged_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    testObj->impl_->onPowerStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPowerStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onPowerStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPowerStateChanged_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPowerStateChanged_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::OFF;
    testObj->impl_->onPowerStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_onPowerStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onPowerStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPowerStateChanged_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPowerStateChanged_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    EXPECT_CALL(*M_PowerManagerAdapter, getIGStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    testObj->impl_->onPowerStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}



/**
 *   @brief This is a test script for the r_call_jp_processor_onPowerStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onPowerStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPowerStateChanged_TC005
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPowerStateChanged_TC005){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    EXPECT_CALL(*M_PowerManagerAdapter, getIGStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State::STANDBY;
    testObj->impl_->onPowerStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    sp<TelephoneManager::StateChangedInfo> info( new TelephoneManager::StateChangedInfo() );
    info->isNormal = true;
    ret_param_0->spRef = info;
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    //EXPECT_CALL(*M_Common, getConfig(_)).Times(3).WillOnce(Return("NG"));
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_ACTIVE;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_DIALING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC005
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC005){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_HOLDING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC006
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC006){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_WAITING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC007
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC007){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_ALERTING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC008
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC008){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_INCOMING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC009
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC009){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_DISCONNECTED;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC010
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC010){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = 100;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC011
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC011){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_DISCONNECTING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(6);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC012
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC012){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_DISCONNECTING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(2);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC013
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC013){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_DISCONNECTING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(3);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC014
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC014){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_DISCONNECTING;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(0);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC015
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC015){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    RCallProcessor::Impl st;
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->timerHandler = new OEMCallTimer(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_002(_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, requestTelMute(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_PowerManagerAdapter, isIGON()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_ConfigManager, isSubscripted(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_PowerManagerAdapter, getACCStatus()).WillRepeatedly(Return(MCU_VALUE_STATUS::MCU_STATUS_ON));
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();

    ret_param_0->spRef = new RefBase();
    ret_param_0->getObject(info);
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_IDLE;
    testObj->impl_-> powerMode = 10;
    testObj->impl_-> state  = State(20);
    testObj->impl_->onCallStateChanged(ret_param_0);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onCallStateChanged function
 *   @classID r_call_jp_processor
 *   @methodID onCallStateChanged
 *   @paramList uint32_t timerId
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onCallStateChanged_TC016
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onCallStateChanged_TC016){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_TelephoneManager, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).WillRepeatedly(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    sl::Message *msg = new sl::Message();
    android::sp<TelephoneManager::StateChangedInfo> info = new TelephoneManager::StateChangedInfo();
    info->isNormal = false;
    info->state = telephony::TelephonyManager::PRECISE_CALL_STATE_IDLE;
    msg->spRef = info;
    testObj->impl_->state = State::VOICE_COMMUNICATION;
    testObj->impl_->onCallStateChanged(msg);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_updateState function
 *   @classID r_call_jp_processor
 *   @methodID updateState
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_updateState_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_updateState_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    State newState = (State) 20;
    testObj->impl_->updateState(newState);
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_updateState function
 *   @classID r_call_jp_processor
 *   @methodID updateState
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_updateState_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_updateState_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    State newState = (State) 20;
    testObj->impl_->updateState(newState);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_updateState function
 *   @classID r_call_jp_processor
 *   @methodID updateState
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_updateState_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_updateState_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    State newState = (State) 20;
    testObj->impl_->updateState(newState);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_requestScreen function
 *   @classID r_call_jp_processor
 *   @methodID requestScreen
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_requestScreen_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_requestScreen_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->requestScreen("OK");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_requestScreen function
 *   @classID r_call_jp_processor
 *   @methodID requestScreen
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_requestScreen_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_requestScreen_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->requestScreen("OK");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_requestScreen function
 *   @classID r_call_jp_processor
 *   @methodID requestScreen
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_requestScreen_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_requestScreen_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->requestScreen("OK");
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpCalling function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpCalling
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpCalling_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpCalling_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    testObj->impl_->cleanUpCalling();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpCalling function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpCalling
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpCalling_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpCalling_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    testObj->impl_->cleanUpCalling();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpCalling function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpCalling
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpCalling_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpCalling_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    testObj->impl_->cleanUpCalling();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpCalling function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpCalling
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpCalling_TC004
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpCalling_TC004){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->spAdapters->spTelephoneManager  = nullptr;
    // EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    testObj->impl_->cleanUpCalling();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpOtherModule function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpOtherModule
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpOtherModule_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpOtherModule_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    testObj->impl_->cleanUpOtherModule();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpOtherModule function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpOtherModule
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpOtherModule_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpOtherModule_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    testObj->impl_->cleanUpOtherModule();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_cleanUpOtherModule function
 *   @classID r_call_jp_processor
 *   @methodID cleanUpOtherModule
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_cleanUpOtherModule_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_cleanUpOtherModule_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    testObj->impl_->cleanUpOtherModule();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_handleConfigChanged function
 *   @classID r_call_jp_processor
 *   @methodID handleConfigChanged
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_handleConfigChanged_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_handleConfigChanged_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->handleConfigChanged();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_handleConfigChanged function
 *   @classID r_call_jp_processor
 *   @methodID handleConfigChanged
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_handleConfigChanged_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_handleConfigChanged_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->handleConfigChanged();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_handleConfigChanged function
 *   @classID r_call_jp_processor
 *   @methodID handleConfigChanged
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_handleConfigChanged_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_handleConfigChanged_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->handleConfigChanged();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onTerminate function
 *   @classID r_call_jp_processor
 *   @methodID onTerminate
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onTerminate_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onTerminate_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "OK";
    const std::string name = "OK";
    testObj->impl_->onTerminate(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onTerminate function
 *   @classID r_call_jp_processor
 *   @methodID onTerminate
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onTerminate_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onTerminate_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "OK";
    const std::string name = "OK";
    testObj->impl_->onTerminate(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onTerminate function
 *   @classID r_call_jp_processor
 *   @methodID onTerminate
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onTerminate_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onTerminate_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "OK";
    const std::string name = "OK";
    testObj->impl_->onTerminate(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doStop function
 *   @classID r_call_jp_processor
 *   @methodID doStop
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doStop_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doStop_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "OK";
    const std::string name = "OK";
    testObj->impl_->doStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doStop function
 *   @classID r_call_jp_processor
 *   @methodID doStop
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doStop_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doStop_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "OK";
    const std::string name = "OK";
    testObj->impl_->doStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_doStop function
 *   @classID r_call_jp_processor
 *   @methodID doStop
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_doStop_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_doStop_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    const std::string type = "OK";
    const std::string name = "OK";
    testObj->impl_->doStop(type, name);
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPlayAudio function
 *   @classID r_call_jp_processor
 *   @methodID onPlayAudio
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPlayAudio_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPlayAudio_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->onPlayAudio();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPlayAudio function
 *   @classID r_call_jp_processor
 *   @methodID onPlayAudio
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPlayAudio_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPlayAudio_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->onPlayAudio();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onPlayAudio function
 *   @classID r_call_jp_processor
 *   @methodID onPlayAudio
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onPlayAudio_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onPlayAudio_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->onPlayAudio();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSendDataError function
 *   @classID r_call_jp_processor
 *   @methodID onSendDataError
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSendDataError_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSendDataError_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->state = State::VOICE_COMMUNICATION;
    testObj->impl_->onSendDataError();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_onSendDataError function
 *   @classID r_call_jp_processor
 *   @methodID onSendDataError
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSendDataError_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSendDataError_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->state = State::VOICE_COMMUNICATION;
    testObj->impl_->onSendDataError();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_onSendDataError function
 *   @classID r_call_jp_processor
 *   @methodID onSendDataError
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_onSendDataError_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_onSendDataError_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);
    testObj->impl_->state = State::COMMUNICATING_DATA;
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));
    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());
    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->onSendDataError();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_handleCallTimeOut function
 *   @classID r_call_jp_processor
 *   @methodID handleCallTimeOut
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_handleCallTimeOut_TC001
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_handleCallTimeOut_TC001){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);

    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());


    testObj->impl_->state = State::COMMUNICATING_DATA;
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));

    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->handleCallTimeOut();
    EXPECT_EQ(Bypass, true);
#endif
}

/**
 *   @brief This is a test script for the r_call_jp_processor_handleCallTimeOut function
 *   @classID r_call_jp_processor
 *   @methodID handleCallTimeOut
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_handleCallTimeOut_TC002
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_handleCallTimeOut_TC002){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);

    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());


    testObj->impl_->state = State::COMMUNICATING_DATA;
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));

    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->handleCallTimeOut();
    EXPECT_EQ(Bypass, true);
#endif
}


/**
 *   @brief This is a test script for the r_call_jp_processor_handleCallTimeOut function
 *   @classID r_call_jp_processor
 *   @methodID handleCallTimeOut
 *   @paramList android::sp<OemCallHandler> spHandler, std::shared_ptr< AdapterLocator > adapters
 *   @priority P2
 *   @resolution_Method
 *   @test_condition
 *   @test_Coverage_Item
 *   @test_case_ID r_call_jp_processorTest_handleCallTimeOut_TC003
 *   @test_type functionality
 *   @test_objective
 *   @test_precon
 *   @test_input
 *   @test_expected_result
 *   @test_module
 *   @design_id
 */
TEST_F(r_call_jp_processorTest, r_call_jp_processor_handleCallTimeOut_TC003){
// Please enable and make test code here!!
#if 1
    // Please check source file, make mock files and insert EXPECT_CALL for callee functions.
    RCallProcessor *testObj = new RCallProcessor();
    testObj->impl_->spAdapters = std::make_shared<AdapterLocator>(nullptr);

    android::sp<Timer> t = new Timer(testObj->impl_->timerHandler, 2);
    testObj->impl_->timers.push_back(std::move(t));
    EXPECT_CALL(*M_Timer, stop()).WillRepeatedly(Return());


    testObj->impl_->state = State::COMMUNICATING_DATA;
    EXPECT_CALL(*M_AudioManagerAdapter, requestBPlayAudio(_)).WillRepeatedly(Return(false));
    EXPECT_CALL(*M_Handler, sendMessageDelayed(_,_)).WillRepeatedly(Return(true));
    sp<sl::Message> ret_param_0 = sp<sl::Message>(new sl::Message);
    EXPECT_CALL(*M_Handler, obtainMessage_005(_,_,_)).WillRepeatedly(Return(ret_param_0));
    EXPECT_CALL(*M_AudioManagerAdapter, isAudioPlaying()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_AudioManagerAdapter, requestBStopAudio()).WillRepeatedly(Return(false));

    EXPECT_CALL(*M_HmiManagerAdapter, requestPattern(_,_)).Times(1);
    EXPECT_CALL(*M_TelephoneManager, stop()).Times(1);
    EXPECT_CALL(*M_AudioManagerAdapter, requestCloseCallAudioPath()).WillRepeatedly(Return(true));
    EXPECT_CALL(*M_Common, getConfig(_)).Times(1).WillOnce(Return(""));
    EXPECT_CALL(*M_AudioManagerAdapter, requestMuteBySomeIP(_)).WillRepeatedly(Return(true));

    EXPECT_CALL(*M_Handler, obtainMessage_003(_,_)).WillRepeatedly(Return(ret_param_0));
    testObj->impl_->handleCallTimeOut();
    EXPECT_EQ(Bypass, true);
#endif
}



